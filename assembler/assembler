#!/usr/bin/env python3
#
# VICERA ASSEMBLER
# TODO: Make an actual assembler.
#
# This assembler is probably the worst
# assembler I have ever written.
#
import sys, re
from enum import IntEnum

# Instructions
IHALT       = 0x00
INOP        = 0x01

IPUSH_NN    = 0x02
IPUSHA      = 0x05
IPOP_NN     = 0x06
IPOPA       = 0x09

IMOV_RR     = 0x0a
IMOV_PR     = 0x3b
IMOV_RN     = 0x42
IMOV_PN     = 0x49

IMOV_RP     = 0x4a
IMOV_SP     = 0x51

IMOV_ARR    = 0x52
IMOV_ANN    = 0x54
IMOV_RRA    = 0x55
IMOV_NNA    = 0x57

IMOV_RRNN   = 0x58

IADD_R      = 0x5b
IADD_N      = 0x62
IADD_P      = 0x63

ISUB_R      = 0x64
ISUB_N      = 0x6b
ISUB_P      = 0x6c

IAND_R      = 0x6d
IAND_N      = 0x74
IAND_P      = 0x75

IOR_R       = 0x76
IOR_N       = 0x7d
IOR_P       = 0x7e

IXOR_R      = 0x7f
IXOR_N      = 0x86
IXOR_P      = 0x87

IINC_R      = 0x88
IINC_RR     = 0x8f

IDEC_R      = 0x92
IDEC_RR     = 0x99

ISL_R       = 0x9c
ISR_R       = 0xa3

ICP_R       = 0xaa
ICP_N       = 0xb1
ICP_P       = 0xb2

IJP_NN      = 0xb3
IJP_P       = 0xb4

IJC_NN      = 0xb5
IJC_P       = 0xb6

IJZ_NN      = 0xb7
IJZ_P       = 0xb8

IJN_NN      = 0xb9
IJN_P       = 0xba

ICALL_NN    = 0xbb
ICALL_P     = 0xbc

IRET        = 0xbd

IDUMP_R     = 0xbe
IDUMP_M     = 0xbf

ISLP        = 0xc0

# 8-bit registers
registers_8 = [
        'A',
        'B',
        'C',
        'D',
        'E',
        'H',
        'L'
        ]
# 16-bit registers
registers_16 = [
        'HL',
        'BC',
        'DE'
]
# Stack pointer
stackptr = "SP"
# Pointer registers
registers_ptr = [
        'HL',
        'BC',
        'DE'
]

# Fuck you Python, pls add enum
BIT8    = 0 # 8-bit register
BIT16   = 1 # 16-bit register
PTR     = 2 # Pointer (example: (HL))
STACK   = 3 # Stack pointer
ADDR    = 4 # Address (example: (&1fb2))

def log(message):
    for line in message.split('\n'):
        print(f"[#] {line}", file=sys.stderr)
def die(message):
    for line in message.split('\n'):
        print(f"[X] {line}", file=sys.stderr)
    sys.exit(1)
# For syntax errors
def syndie(line, message):
    die(f"Error at {line}: {message}")

# 8-bit to 16-bit
def c8to16(v):
    return [ v // 0x100, v % 0x100 ]
# To check the value type.
# Appending a 16-bits integer.
def append_int(arr: list, v: list):
    if v[0] == -1:
        arr += v
    elif len(v) == 1:
        arr += [0x00, v[0]]
    else:
        arr += v

def parse_program(program: str):
    splited_program = program.split("\n")
    parsed_program = []

    # For debugging purposes. The line number is recorded.
    for num, line in enumerate(splited_program):
        line = line.split(";")[0].strip()
        if line != "":
            # If the line is not empty, parse and append.
            pline = (line.split()[0], [
                x.strip() for x in 
                ' '.join(line.split()[1:]).split(',')])
            parsed_program.append((num + 1, pline))

    return parsed_program

def string_to_value(value):
    # Checking if this is a pointer.
    is_ptr = False
    if value.startswith('(') and value.endswith(')'):
        is_ptr = True
        value = value[1:-1]

    # Hexadecimal values
    if      value.startswith("0x"):
        v = int(value[2:], 16)
    elif    value.startswith("&"):
        v = int(value[1:], 16)
    # Binary values
    elif    value.startswith("0b"):
        v = int(value[2:], 2)
    # Octal values
    elif    value.startswith("0") and len(value) > 1:
        v = int(value[1:], 8)
    # Decimal values
    elif    value.isnumeric():
        v = int(value)
    # Single character
    elif    re.match(r"'.'", value) and len(value) == 3:
        v = ord(value[1])

    ## Registers
    # 8-bit registers
    elif    value in registers_8:
        return (BIT8, registers_8.index(value))
    # 16-bit registers
    elif    value in registers_16:
        if is_ptr:
            return (PTR, registers_ptr.index(value))
        else:
            return (BIT16, registers_16.index(value))
    # Stack pointer
    elif    value == stackptr:
        return (STACK, 0)
    else:
        if is_ptr:
            return (ADDR, [-1, value])
        else:
            return [-1, value]
    
    ### integer into bytes ###
    arr = []
    while v != 0:
        arr.append(v % 0x100)
        v >>= 8
    if arr == []:
        arr = [0]
    
    if is_ptr:
        if len(arr) == 2:
            return (ADDR, arr[::-1])
        elif len(arr) == 1:
            return (ADDR, [0x00, arr[0]])
        else:
            return None
    else:
        return arr[::-1]

class AssemblyParse():
    def __init__(self, program: list):
        self.program = program
        self.labels = {}

    def assemble(self):
        output = []
        labels = {}

        for line in self.program:
            linenum = line[0]
            opcode = line[1][0].lower()
            args = [ string_to_value(x) for x in line[1][1] ]
            
            # print(opcode, args)
            # halt
            if opcode == "halt":
                output.append(IHALT)
            # nop
            elif opcode == "nop":
                output.append(INOP)
            # push rr
            elif opcode == "push" and args[0][0] == BIT16:
                output.append(IPUSH_NN + args[0][1])
            # pusha
            elif opcode == "pusha":
                output.append(IPUSHA)
            # pop rr
            elif opcode == "pop" and args[0][0] == BIT16:
                output.append(IPOP_NN + args[0][1])
            # popa
            elif opcode == "popa":
                output.append(IPOPA)
            # mov
            elif opcode == "mov" and type(args[0]) == tuple:
                # mov *, (r/rr/(rr)/(nn))
                if type(args[1]) == tuple:
                    # mov r, r
                    if args[0][0] == BIT8 and args[1][0] == BIT8:
                        output.append(IMOV_RR + (args[0][1] * 7) + args[1][1])
                    # mov (HL), r
                    elif args[0] == (PTR, 0) and args[1][0] == BIT8:
                        output.append(IMOV_PR + args[1][1])
                    # mov r, (HL)
                    elif args[0][0] == BIT8 and args[1] == (PTR, 0):
                        output.append(IMOV_RP + args[0][1])
                    # mov A, (BC/DE)
                    elif args[0] == (BIT8, 0) and args[1][0] == PTR and args[1][1] >= 1:
                        output.append(IMOV_ARR + args[1][1] - 1)
                    # mov A, nn
                    elif args[0] == (BIT8, 0) and args[1][0] == ADDR:
                        output.append(IMOV_ANN)
                        append_int(output, args[1][1])
                    # mov (BC/DE), A
                    elif args[1] == (BIT8, 0) and args[0][0] == PTR and args[0][1] >= 1:
                        output.append(IMOV_RRA + args[0][1] - 1)
                    # mov nn, A
                    elif args[1] == (BIT8, 0) and args[0][0] == ADDR:
                        output.append(IMOV_NNA)
                        append_int(output, args[0][1])
                    # Nothing
                    else:
                        syndie(linenum, "Invalid arguments.")
                
                # mov *, n
                elif type(args[1]) == list:
                    # mov r, n
                    if args[0][0] == BIT8:
                        output.append(IMOV_RN + args[0][1])
                        output.append(args[1][0])
                    # mov (HL), n
                    elif args[0] == (PTR, 0):
                        output.append(IMOV_PN)
                        output.append(args[1][0])
                    # mov SP, nn
                    elif args[0] == (STACK, 0):
                        output.append(IMOV_SP)
                        append_int(output, args[1])
                    # mov HL/BC/DE, nn
                    elif args[0][0] == BIT16:
                        output.append(IMOV_RRNN + args[0][1])
                        append_int(output, args[1])
                    # nothing
                    else:
                        syndie(linenum, "Invalid arguments.")
                else:
                    syndie(linenum, "Invalid arguments.")
            # add
            elif opcode == "add":
                # add n
                if type(args[0]) == tuple and args[0][0] == BIT8:
                    output.append(IADD_R + args[0][1])
                # add r
                elif type(args[0]) == list:
                    output.append(IADD_N)
                    output.append(args[0][0])
                # add (HL)
                elif args[0] == (PTR, 0):
                    output.append(IADD_P)
                else:
                    syndie(linenum, "Invalid arguments.")
            # sub
            elif opcode == "sub":
                if type(args[0]) == tuple and args[0][0] == BIT8:
                    output.append(ISUB_R + args[0][1])
                elif type(args[0]) == list:
                    output.append(ISUB_N)
                    output.append(args[0][0])
                elif args[0] == (PTR, 0):
                    output.append(ISUB_P)
                else:
                    syndie(linenum, "Invalid arguments.")
            # and
            elif opcode == "and":
                if type(args[0]) == tuple and args[0][0] == BIT8:
                    output.append(IAND_R + args[0][1])
                elif type(args[0]) == list:
                    output.append(IAND_N)
                    output.append(args[0][0])
                elif args[0] == (PTR, 0):
                    output.append(IAND_P)
                else:
                    syndie(linenum, "Invalid arguments.")
            # or
            elif opcode == "or":
                if type(args[0]) == tuple and args[0][0] == BIT8:
                    output.append(IOR_R + args[0][1])
                elif type(args[0]) == list:
                    output.append(IOR_N)
                    output.append(args[0][0])
                elif args[0] == (PTR, 0):
                    output.append(IOR_P)
                else:
                    syndie(linenum, "Invalid arguments.")
            # xor
            elif opcode == "xor":
                if type(args[0]) == tuple and args[0][0] == BIT8:
                    output.append(IXOR_R + args[0][1])
                elif type(args[0]) == list:
                    output.append(IXOR_N)
                    output.append(args[0][0])
                elif args[0] == (PTR, 0):
                    output.append(IXOR_P)
                else:
                    syndie(linenum, "Invalid arguments.")
            # inc
            elif opcode == "inc":
                if type(args[0]) == tuple and args[0][0] == BIT8:
                    output.append(IINC_R + args[0][1])
                elif type(args[0]) == tuple and args[0][0] == BIT16:
                    output.append(IINC_RR + args[0][1])
                else:
                    syndie(linenum, "Invalid arguments.")
            # dec
            elif opcode == "dec":
                if type(args[0]) == tuple and args[0][0] == BIT8:
                    output.append(IDEC_R + args[0][1])
                elif type(args[0]) == tuple and args[0][0] == BIT16:
                    output.append(IDEC_RR + args[0][1])
                else:
                    syndie(linenum, "Invalid arguments.")
            # sl
            elif opcode == "sl" and type(args[0]) == tuple and args[0][0] == BIT8:
                output.append(ISL_R + args[0][1])
            # sr
            elif opcode == "sr" and type(args[0]) == tuple and args[0][0] == BIT8:
                output.append(ISR_R + args[0][1])
            # cp
            elif opcode == "cp":
                if type(args[0]) == tuple and args[0][0] == BIT8:
                    output.append(ICP_R + args[0][1])
                elif type(args[0]) == list:
                    output.append(ICP_N)
                    output.append(args[0][0])
                elif args[0] == (PTR, 0):
                    output.append(ICP_P)
                else:
                    syndie(linenum, "Invalid arguments.")
            # jp
            elif opcode == "jp":
                if type(args[0]) == list:
                    output.append(IJP_NN)
                    append_int(output, args[0])
                elif args[0] == (PTR, 0):
                    output.append(IJP_P)
            # jc
            elif opcode == "jc":
                if type(args[0]) == list:
                    output.append(IJC_NN)
                    append_int(output, args[0])
                elif args[0] == (PTR, 0):
                    output.append(IJC_P)
                else:
                    syndie(linenum, "Invalid arguments.")
            # jz
            elif opcode == "jz":
                if type(args[0]) == list:
                    output.append(IJZ_NN)
                    append_int(output, args[0])
                elif args[0] == (PTR, 0):
                    output.append(IJZ_P)
                else:
                    syndie(linenum, "Invalid arguments.")
            # jn
            elif opcode == "jn":
                if type(args[0]) == list:
                    output.append(IJN_NN)
                    append_int(output, args[0])
                elif args[0] == (PTR, 0):
                    output.append(IJN_P)
                else:
                    syndie(linenum, "Invalid arguments.")
            # call
            elif opcode == "call":
                if type(args[0]) == list:
                    output.append(ICALL_NN)
                    append_int(output, args[0])
                elif args[0] == (PTR, 0):
                    output.append(ICALL_P)
                else:
                    syndie(linenum, "Invalid arguments.")
            # ret
            elif opcode == "ret":
                output.append(IRET)
            # dump
            elif opcode == "dumpr":
                output.append(IDUMP_R)
            elif opcode == "dumpm":
                if type(args[0]) == list:
                    output.append(IDUMP_M)
                    append_int(output, args[0])
                else:
                    syndie(linenum, "Invalid arguments.")
            # slp
            elif opcode == "slp":
                output.append(ISLP)
            
            ### Assembler-wise instructions
            # Labels
            elif opcode.endswith(":"):
                labels[opcode[:-1]] = c8to16(len(output))
            # db
            elif opcode == "db":
                for entry in args:
                    if type(entry) != list:
                        syndie(linenum, "Invalid arguments.")
                    else:
                        output += entry

            # none
            else:
                syndie(linenum, "Invalid command.")
        
        """
        print("=========================")
        print(output)
        print("=========================")
        test = list(filter(lambda n: n != 0xff and type(n) != str, output))
        print(test)
        print(labels)
        """

        log("Replacing labels by it's appropriate values...")
        # Labels has been successfully indexed. Poggers
        for ptr, instr in enumerate(output):
            if instr == -1:
                label = labels[output[ptr+1].lower()]
                output[ptr] = label[0]
                output[ptr+1] = label[1]
        
        return output
        # print(output)

def main():
    log("""-----------
__     ___                    
\ \   / (_) ___ ___ _ __ __ _ 
 \ \ / /| |/ __/ _ \ '__/ _` | Tiny assembler by
  \ V / | | (_|  __/ | | (_| | Matthilde "h34ting4ppliance" Condenseau
   \_/  |_|\___\___|_|  \__,_| Made for testing purposes.
-----------""")

    if len(sys.argv) != 2:
        sys.exit(1)
    prgm = open(sys.argv[1]).read()
    parsed_prgm = parse_program(prgm)
    
    print('\n'.join([str(x) for x in parsed_prgm]))
    asm = AssemblyParse(parsed_prgm)
    
    b = asm.assemble()
    with open("a.vicera", "wb") as f:
        f.write(bytearray(b))
        
if __name__ == "__main__":
    main()
